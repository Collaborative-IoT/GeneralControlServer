use crate::data_store::db_models::
{DBUser,
 DBRoom,
 DBScheduledRoom,
 DBScheduledRoomAttendance,
 DBFollower};
use futures_util::Future;
use crate::data_store::sql_execution_handler::ExecutionHandler;
use tokio_postgres::{row::Row, Error};

pub struct CaptureResult{
    pub desc:String,
    pub encountered_error:bool
}

pub async fn capture_new_user(
    execution_handler:&mut ExecutionHandler,
    user:&DBUser)->i32{
        //no user has both a github id and discord id
        //we use -1 for which ever doesn't exist(which is already set in the DBUser)
        let user_already_exist_result = execution_handler.select_user_by_discord_or_github_id(
            user.discord_id.to_owned(),
            user.github_id.to_owned()).await;

        // we haven't ran into db issues and our user doesn't exist
        if  user_already_exist_result.is_ok() &&  user_already_exist_result.unwrap().len() == 0{
            let insert_result = execution_handler.insert_user(user).await;
            if insert_result.is_ok(){
                let user_id:i32 = insert_result.unwrap();
                return user_id;
            }
            else{
                return -1 as i32;
            }
        }
        else{
            return -1 as i32;
        }
}   

pub async fn capture_new_room(
    execution_handler:&mut ExecutionHandler,
    room:&DBRoom)->i32{
        let insert_future_for_execution = execution_handler.insert_room(room);
        return capture_room(insert_future_for_execution).await;
}

pub async fn capture_new_scheduled_room(
    execution_handler:&mut ExecutionHandler,
    room:&DBScheduledRoom
)->i32{
    let future_for_execution = execution_handler.insert_scheduled_room(room);
    return capture_room(future_for_execution).await;
}

pub async fn capture_new_scheduled_room_attendance(
    execution_handler:&mut ExecutionHandler,
    attendance:&DBScheduledRoomAttendance
)->CaptureResult{
    let insert_future_for_execution = execution_handler.insert_scheduled_room_attendance(attendance);
    return handle_basic_insert_with_no_returning(insert_future_for_execution).await;
}

pub async fn capture_new_follower(
    execution_handler:&mut ExecutionHandler,
    follower:&DBFollower)->CaptureResult{
        let insert_future_for_execution = execution_handler.insert_follower(follower);
        return handle_basic_insert_with_no_returning(insert_future_for_execution).await;
}

//handles logic for room capture 
//takes in future generated by room insert methods
//in the sql_execution_handler.
//could be more generic to handle other similar cases.
async fn capture_room(
    future_exc:impl Future<Output = Result<i32, Error>>)->i32{
        let insert_result = future_exc.await;
        if insert_result.is_ok(){
            let room_id:i32 = insert_result.unwrap();
            return room_id;
        }
        else{
            return -1 as i32;
        }
}

//handles captures that doesn't require
//any data to be returned from it
//returns whether or not issues occured
async fn handle_basic_insert_with_no_returning(
    future_exc:impl Future<Output = Result<(), Error>>)->CaptureResult{
        let insert_result = future_exc.await;
        if insert_result.is_ok(){
            return CaptureResult{
                desc:"Action Successful".to_owned(),
                encountered_error:false
            }
        }
        else{
            return CaptureResult{
                desc:"Issue with execution".to_owned(),
                encountered_error:true
            }
        }
    }

//checks select future to determine if there is
//a row with the same credentials already present
//before insertion
async fn insert_will_be_duplicate(
    future_exc:impl Future<Output = Result<Vec<Row>, Error>>)->bool{
        let future_result = future_exc.await;
        if future_result.is_ok(){
            let selected_rows = future_result.unwrap();
            if selected_rows.len() != 1{
                return true;
            }
            else{
                return false;
            }
        }
        else{
            //return will be duplicate to signify
            //issue with future execution
            return true;
        }
}