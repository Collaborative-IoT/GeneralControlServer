use crate::data_store::db_models::
{DBUser,
 DBRoom,
 DBScheduledRoom};
use crate::data_store::sql_execution_handler::ExecutionHandler;

pub async fn capture_new_user(
    execution_handler:&mut ExecutionHandler,
    user:&DBUser)->i32{
        //no user has both a github id and discord id
        //we use -1 for which ever doesn't exist(which is already set in the DBUser)
        let user_already_exist_result = execution_handler.select_user_by_discord_or_github_id(
            user.discord_id.to_owned(),
            user.github_id.to_owned()).await;

        // we haven't ran into db issues and our user doesn't exist
        if result.is_ok() && result.unwrap().len() == 0{
            let insert_result = execution_handler.insert_user(user).await;
            if result.is_ok(){
                let user_id:i32 = insert_result.unwrap();
                return user_id;
            }
            else{
                return -1 as i32;
            }
        }
        else{
            return -1 as i32;
        }
}   

pub async fn capture_new_room(
    execution_handler:&mut ExecutionHandler,
    room:&DBRoom)->i32{
        let future_for_execution = execution_handler.insert_room(room).await;
        return capture_room(execution_handler,future_for_execution).await;
}

pub async fn capture_new_scheduled_room(
    execution_handler:&mut ExecutionHandler,
    room:&DBScheduledRoom
)->i32{
    let future_for_execution = execution_handler.insert_scheduled_room(room).await;
    return capture_room(execution_handler,future_for_execution).await;
}

//handles logic for room capture 
//takes in future generated by room insert methods
//in the sql_execution_handler.
async fn capture_room(
    execution_handler:&mut ExecutionHandler,
    future_exc:impl Future<Output = Result<i32, Error>>)->i32{
        let insert_result = future_exc.await;
        if insert_result.is_ok(){
            let room_id:i32 = insert_result.unwrap();
            return room_id;
        }
        else{
            return -1 as i32;
        }
}